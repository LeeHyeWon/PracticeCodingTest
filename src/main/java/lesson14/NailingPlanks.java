package lesson14;

public class NailingPlanks {
    /**
     * N개의 정수로 구성된 두 개의 비어 있지 않은 배열 A와 B가 제공됩니다. 이 배열은 N 판자를 나타냅니다. 보다 정확하게는 A[K]가 K번째 플랭크의 시작이고 B[K]가 끝입니다.
     *
     * 다음으로 M개의 정수로 구성된 비어 있지 않은 배열 C가 제공됩니다. 이 배열은 M개의 못을 나타냅니다. 더 정확히 말하면 C[I]는 I번째 못을 망치질할 수 있는 위치입니다.
     *
     * 판자(A[K], B[K])는 A[K] ≤ C[I] ≤ B[K]와 같은 못 C[I]가 있으면 못을 박았다고 합니다.
     *
     * 목표는 모든 판자가 못을 박을 때까지 사용해야 하는 못의 최소 수를 찾는 것입니다. 즉, 첫 번째 J 못만 사용한 후에 모든 판자가 못을 박을 수 있는 값 J를 찾아야 합니다. 보다 정확하게는 0 ≤ K < N인 모든 판자(A[K], B[K])에 대해 I < J 및 A[K] ≤ C[I] ≤인 못 C[I]가 있어야 합니다. ㄴ[케이].
     *
     * 예를 들어 주어진 배열 A, B는 다음과 같습니다.
     *
     *     A[0] = 1 B[0] = 4
     *     A[1] = 4 B[1] = 5
     *     A[2] = 5 B[2] = 9
     *     A[3] = 8 B[3] = 10
     * 네 개의 판자가 표시됩니다: [1, 4], [4, 5], [5, 9] 및 [8, 10].
     *
     * 주어진 배열 C는 다음과 같습니다.
     *
     *     C[0] = 4
     *     C[1] = 6
     *     C[2] = 7
     *     C[3] = 10
     *     C[4] = 2
     * 다음 손톱을 사용하는 경우:
     *
     * 0이면 판자 [1, 4]와 [4, 5]가 모두 못을 박을 것입니다.
     * 0, 1, 판자 [1, 4], [4, 5] 및 [5, 9]가 못을 박을 것입니다.
     * 0, 1, 2, 판자 [1, 4], [4, 5] 및 [5, 9]가 못을 박을 것입니다.
     * 0, 1, 2, 3이면 모든 판자가 못을 박을 것입니다.
     * 따라서 4는 모든 널빤지를 못 박을 수 있도록 순차적으로 사용되는 최소 못 수입니다.
     *
     * 함수 작성:
     *
     * 클래스 솔루션 { 공개 int 솔루션(int[] A, int[] B, int[] C); }
     *
     * N개의 정수로 구성된 두 개의 비어 있지 않은 배열 A와 B와 M개의 정수로 구성된 비어 있지 않은 배열 C가 주어지면 모든 널빤지를 못 박을 수 있도록 순차적으로 사용되는 못의 최소 수를 반환합니다.
     *
     * 모든 널빤지를 못 박을 수 없는 경우 함수는 -1을 반환해야 합니다.
     * 예를 들어 주어진 배열 A, B, C는 다음과 같습니다.
     *
     *     A[0] = 1 B[0] = 4
     *     A[1] = 4 B[1] = 5
     *     A[2] = 5 B[2] = 9
     *     A[3] = 8 B[3] = 10
     *
     *     C[0] = 4
     *     C[1] = 6
     *     C[2] = 7
     *     C[3] = 10
     *     C[4] = 2
     * 함수는 위에서 설명한 대로 4를 반환해야 합니다.
     *
     * 다음 가정에 대한 효율적인 알고리즘을 작성하십시오.
     *
     * N 및 M은 [1..30,000] 범위 내의 정수입니다.
     * 배열 A, B 및 C의 각 요소는 [1..2*M] 범위 내의 정수입니다.
     * A[K] ≤ B[K].
     */
}
